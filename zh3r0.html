<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
        <link rel="stylesheet" href="css/custom.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/vs2015.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
        <title>zh3r0 CTF Writeups</title>
    </head>

    <body>
        <nav class="navbar navbar-inverse navbar-fixed-top justify-content-center">
            <div class="container-fluid">
              <div class="navbar-header">
                <a class="navbar-brand" href="#">Diamondroxxx</a>
              </div>
              <ul class="nav navbar-nav">
                <li><a href="index.html">Home</a></li>
                <li class="dropdown active" id="nav-dropdown">
                    <a class="dropdown-toggle" data-toggle="dropdown" href="#">CTFs
                    <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      <li><a href="#">zh3r0</a></li>
                    </ul>
                </li>
              </ul>
            </div>
        </nav>

        <div class="container" style="margin-top:50px; background-color: rgba(255, 255, 255, .01); width: 75vw">
            <h1>zh3r0 CTF</h1>
            <p>This was my first proper CTF, and it was a very fun experience. I was able to solve two challenges and learnt a lot in the process.</p>
            <hr/>

            <!-- Heading, image, and source code-->
            <h2>Twist And Shout</h2>
            <img src="img/Twist_and_shout.png" style="height: 70vh; min-height: 300px; display: block; margin-left: auto; margin-right: auto;">
            <figure class="figure">
                <div>
                    <pre id="code-block"><code>from secret import flag
import os  
import random
                        
state_len = 624*4
right_pad = random.randint(0,state_len-len(flag))
left_pad = state_len-len(flag)-right_pad
state_bytes = os.urandom(left_pad)+flag+os.urandom(right_pad)
state = tuple( int.from_bytes(state_bytes[i:i+4],&#39;big&#39;) for i in range(0,state_len,4) )
random.setstate((3,state+(624,),None))
outputs = [random.getrandbits(32) for i in range(624)]
print(*outputs,sep=&#39;\n&#39;)</code></pre>
                </div>
                <figcaption class="figure-caption"><em>challenge.py, the source code provided</em></figcaption>
            </figure>

            <h3>The Goal</h3><hr/>
            <p>Looking at the code, we can see that after some intial padding, the flag is used as the "state" for the random number generation. Therefore, if we are able to recover the state used to generate the numbers provided in output, we will have recovered the flag.</p>
            <p>The main vulnerability in this is the provision of 624 consecutive bytes created by the <code id="inline-code">random.getrandbits()</code> method. To understand why, we must first understand the algorithm used by Python's random library, the Mersenne Twister. </p>

            <h3>Mersenne Twister</h3><hr/>
            <p>The standardised version of Mersenne Twister used by Python is MT19937, which gets its name from its period (the number of numbers the algorithm generates before it loops) which is the Mersenne Prime 2<sup>19937</sup> - 1. However, this does not mean we need 2<sup>19937</sup> - 1 consecutive values to reverse the algorithm.</p>
            <p>The algorithm stores an array of integers (this can be accessed by <code id="inline-code">random.getstate()</code>) and dispenses them one by one as requested. This number alone would not be random enough however, and thus an additional step called tempering is applied. In the case of MT19937, the array stores 624 32-bit integers. Once the array is exhausted, a new array is then created based on the old state. This step is called twisting.</p>
            <p>The first part we must undo is tempering.</p>

            <p></p>
            <h4>Tempering</h4>
            <p>The tempering process needs to be quick and easy for a computer to perform and thus is done using a series of bitwise operations.</p>
            <!-- Temper function -->
            <figure class="figure">
                <div>
                    <pre id="code-block"><code>def temper(y):
    y ^= y &gt;&gt; 11
    y ^= (y &lt;&lt; 7) &amp; 0x9D2C5680
    y ^= (y &lt;&lt; 15) &amp; 0xEFC60000
    y ^= y &gt;&gt; 18
    return y &amp; 0xFFFFFFFF</code></pre>
                </div>
                <figcaption class="figure-caption"><em>Tempering in Python code</em></figcaption>
            </figure>
            <p></p>
            <button type="button" class="btn btn-primary" data-toggle="collapse" data-target="#tempering-example">Click here for a more in depth explanation.</button>
            <div id="tempering-example" class="collapse">
                <p>Let <code id="inline-code">y = 11011110101011011011111011101111</code>.</p>

                <h5>Step 1:</h5>
                <p>In the first step we do a bitwise xor on <code id="inline-code">y</code> and <code id="inline-code">y &gt;&gt; 11</code></p>
                <div>
                    <pre id="code-block"><code>11011110101011011011111011101111 XOR
00000000000110111101010110110111 
=
11011110101101100110101101011000</code></pre>
                </div>

                <h4>Step 2:</h4>
                <p>In step 2, <code id="inline-code">y</code> is bit shifted to the left, and then a bitwise and is performed with <code id="inline-code">0x9D2C5680</code>. This is then xored with the previous value of <code id="inline-code">y</code>.</p>
                <div>
                    <pre id="code-block"><code>01011011001101011010110000000000 AND
10011101001011000101011010000000
=
00011001001001000000010000000000 XOR
11011110101101100110101101011000
=
11000111100100100110111101011000</code></pre>
                </div>

                <h4>Step 3:</h4>
                <p>This step is similar to step 2, but with different values.</p>
                <div>
                    <pre id="code-block"><code>00110111101011000000000000000000 AND
11101111110001100000000000000000
=
00100111100001000000000000000000 XOR
01001111101111100010101101011000
=
11100000000101100110111101011000</code></pre>
                </div>

                <h4>Step 4:</h4>
                <p>This step is similar to step 1, but with different values. </p>
                <div>
                    <pre id="code-block"><code>11100000000101100110111101011000 XOR
00000000000000000011100000000101
=
11100000000101100101011101011101</code></pre>
                </div>

                <p>Which gives us our tempered value of <code id="inline-code">y</code>, <code id="inline-code">11100000000101100101011101011101</code>.</p>
            </div>

            <p></p>
            <h4>Untempering</h4>
            <p>The untempering process is largely the same as the tempering process albeit in reverse and with some small changes. I found a <a href="https://github.com/kmyk/mersenne-twister-predictor/blob/master/mt19937predictor.py">github repo</a> which had the code for untempering.</p>
            <figure class="figure">
                <div>
                    <pre id="code-block"><code>def untemper(y):
    y ^= (y >> 18)
    y ^= (y << 15) & 0xEFC60000
    y ^= ((y << 7) & 0x9D2C5680) ^ ((y << 14) & 0x94284000) ^ ((y << 21) & 0x14200000) ^ ((y << 28) & 0x10000000)
    y ^= (y >> 11) ^ (y >> 22)
    return y</code></pre>
                </div>
            </figure>
            <p></p>
            <button type="button" class="btn btn-primary" data-toggle="collapse" data-target="#untempering-example">Click here for a more in depth explanation.</button>
            <div id="untempering-example" class="collapse">
                <p><a href="https://nayak.io/posts/mersenne_twister/">This page</a> explains the procedure well. To show how it works, I'll be continuing with the example from the previous example.</p>
                <h4>Step 4:</h4>
                <p>Step 4 can be reversed by simply redoing step 4 of the tempering process. This is because <code id="inline-code">(a XOR b) XOR b = a</code>. Moreover, after the bitshift, the first 18 bits of the Step 3 value of <code id="inline-code">y</code> are preserved. Thus, when the bitshift occurs again, the bits we need are still there.</p>
                <div>
                    <pre id="code-block"><code>11100000000101100101011101011101 XOR
00000000000000000001001010001110
=
11100000000101100110111101011000</code></pre>
                </div>

                <h4>Step 3:</h4>
                <p>Similarly, step 3 can be reversed by doing step 3 in the tempering process again.</p>
                <div>
                    <pre id="code-block"><code>00110111101011000000000000000000 AND
11101111110001100000000000000000
=
00100111100001000000000000000000 XOR
01001010001110100010101101011000
=
11000111100100100110111101011000</code></pre>
                </div>

                <h4>Step 2:</h4>
                <p>This step is a little bit more complicated but it essentially relies on repeating step 2 of the tempering process with the application of bitmasks. The reason for this is that is because each tome only gets us 7 bits at a time. The github repo I used for the code did this all in one step, while the page I linkes above which has the explanation did it using a loop. After applying that step, this is the result: <code id="inline-code">11011110101101100110101101011000</code>.</p>

                <h4>Step 1:</h4>
                <p>In step 1 of the tempering process, there is a bitshift to the right by 11. Since 11 is less than half of 32, if we just repeat this, weâ€™re going to run into an issue.</p>
                <div>
                    <pre id="code-block"><code>11011110101101100110101101011000 XOR
00000000000110111101011011001101
=
11011110101011011011110110010101</code></pre>
                </div>
                    
                <p>If we compare this to our untempered value (<code id="inline-code">11011110101011011011111011101111</code>), we see that only the first 22 bits are correct. To solve this we can simply xor once more but this time with our original value bitshifted by 22 bits. </p>
                    
                <div><pre id="code-block"><code>11011110101011011011110110010101 XOR
00000000000000000000001101111010
=
11011110101011011011111011101111</code></pre>
                </div>
                <p>This is our untempered value, so we have undone the process!</p>
            </div>
        </div>
    </body>
</html>