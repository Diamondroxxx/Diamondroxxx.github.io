<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
        <link rel="stylesheet" href="../css/custom.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/vs2015.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
        <title>zh3r0 CTF Writeups</title>
    </head>

    <body>
        <nav class="navbar navbar-inverse navbar-fixed-top justify-content-center">
            <div class="container-fluid">
              <div class="navbar-header">
                <a class="navbar-brand" href="#">Diamondroxxx</a>
              </div>
              <ul class="nav navbar-nav">
                <li><a href="index.html">Home</a></li>
                <li class="dropdown active" id="nav-dropdown">
                    <a class="dropdown-toggle" data-toggle="dropdown" href="#">CTFs
                    <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        <li><a href="/CTFS/zh3r0.html">zh3r0</a></li>
                        <li><a href="/CTFs/HSCTF.html">HSCTF</a></li>
                    </ul>
                </li>
              </ul>
            </div>
        </nav>

        <div class="container" style="margin-top:50px; background-color: rgba(255, 255, 255, .01); width: 75vw">
            <h1>zh3r0 CTF</h1>
            <p>This was my first proper CTF, and it was a very fun experience. I was able to solve two challenges and learnt a lot in the process.</p>
            <hr/>

            <!-- Heading, image, and source code-->
            <h2>Twist And Shout</h2>
            <img src="/img/Twist_and_shout.png" style="height: 70vh; min-height: 300px; display: block; margin-left: auto; margin-right: auto;">
            <figure class="figure">
                <div>
                    <pre id="code-block"><code>from secret import flag
import os  
import random
                        
state_len = 624*4
right_pad = random.randint(0,state_len-len(flag))
left_pad = state_len-len(flag)-right_pad
state_bytes = os.urandom(left_pad)+flag+os.urandom(right_pad)
state = tuple( int.from_bytes(state_bytes[i:i+4],&#39;big&#39;) for i in range(0,state_len,4) )
random.setstate((3,state+(624,),None))
outputs = [random.getrandbits(32) for i in range(624)]
print(*outputs,sep=&#39;\n&#39;)</code></pre>
                </div>
                <figcaption class="figure-caption"><em>challenge.py, the source code provided</em></figcaption>
            </figure>

            <h3>The Goal</h3><hr/>
            <p>Looking at the code, we can see that after some intial padding, the flag is used as the "state" for the random number generation. Therefore, if we are able to recover the state used to generate the numbers provided in output, we will have recovered the flag.</p>
            <p>The main vulnerability in this is the provision of 624 consecutive bytes created by the <code id="inline-code">random.getrandbits()</code> method. To understand why, we must first understand the algorithm used by Python's random library, the Mersenne Twister. </p>

            <h3>Mersenne Twister</h3><hr/>
            <p>The standardised version of Mersenne Twister used by Python is MT19937, which gets its name from its period (the number of numbers the algorithm generates before it loops) which is the Mersenne Prime 2<sup>19937</sup> - 1. However, this does not mean we need 2<sup>19937</sup> - 1 consecutive values to reverse the algorithm.</p>
            <p>The algorithm stores an array of integers (this can be accessed by <code id="inline-code">random.getstate()</code>) and dispenses them one by one as requested. This number alone would not be random enough however, and thus an additional step called tempering is applied. In the case of MT19937, the array stores 624 32-bit integers. Once the array is exhausted, a new array is then created based on the old state. This step is called twisting.</p>
            <p>The first part we must undo is tempering.</p>

            <p></p>
            <h4>Tempering</h4>
            <p>The tempering process needs to be quick and easy for a computer to perform and thus is done using a series of bitwise operations.</p>
            <!-- Temper function -->
            <figure class="figure">
                <div>
                    <pre id="code-block"><code>def temper(y):
    y ^= y &gt;&gt; 11
    y ^= (y &lt;&lt; 7) &amp; 0x9D2C5680
    y ^= (y &lt;&lt; 15) &amp; 0xEFC60000
    y ^= y &gt;&gt; 18
    return y &amp; 0xFFFFFFFF</code></pre>
                </div>
                <figcaption class="figure-caption"><em>Tempering in Python code</em></figcaption>
            </figure>
            <p></p>
            <button type="button" class="btn btn-primary" data-toggle="collapse" data-target="#tempering-example">Click here for a more in depth explanation.</button>
            <div id="tempering-example" class="collapse">
                <p>Let <code id="inline-code">y = 11011110101011011011111011101111</code>.</p>

                <h5>Step 1:</h5>
                <p>In the first step we do a bitwise xor on <code id="inline-code">y</code> and <code id="inline-code">y &gt;&gt; 11</code></p>
                <div>
                    <pre id="code-block"><code>11011110101011011011111011101111 XOR
00000000000110111101010110110111 
=
11011110101101100110101101011000</code></pre>
                </div>

                <h4>Step 2:</h4>
                <p>In step 2, <code id="inline-code">y</code> is bit shifted to the left, and then a bitwise and is performed with <code id="inline-code">0x9D2C5680</code>. This is then xored with the previous value of <code id="inline-code">y</code>.</p>
                <div>
                    <pre id="code-block"><code>01011011001101011010110000000000 AND
10011101001011000101011010000000
=
00011001001001000000010000000000 XOR
11011110101101100110101101011000
=
11000111100100100110111101011000</code></pre>
                </div>

                <h4>Step 3:</h4>
                <p>This step is similar to step 2, but with different values.</p>
                <div>
                    <pre id="code-block"><code>00110111101011000000000000000000 AND
11101111110001100000000000000000
=
00100111100001000000000000000000 XOR
01001111101111100010101101011000
=
11100000000101100110111101011000</code></pre>
                </div>

                <h4>Step 4:</h4>
                <p>This step is similar to step 1, but with different values. </p>
                <div>
                    <pre id="code-block"><code>11100000000101100110111101011000 XOR
00000000000000000011100000000101
=
11100000000101100101011101011101</code></pre>
                </div>

                <p>Which gives us our tempered value of <code id="inline-code">y</code>, <code id="inline-code">11100000000101100101011101011101</code>.</p>
            </div>

            <p></p>
            <h4>Untempering</h4>
            <p>The untempering process is largely the same as the tempering process albeit in reverse and with some small changes. I found a <a href="https://github.com/kmyk/mersenne-twister-predictor/blob/master/mt19937predictor.py">github repo</a> which had the code for untempering.</p>
            <!-- Untemper function -->
            <figure class="figure">
                <div>
                    <pre id="code-block"><code>def untemper(y):
    y ^= (y >> 18)
    y ^= (y << 15) & 0xEFC60000
    y ^= ((y << 7) & 0x9D2C5680) ^ ((y << 14) & 0x94284000) ^ ((y << 21) & 0x14200000) ^ ((y << 28) & 0x10000000)
    y ^= (y >> 11) ^ (y >> 22)
    return y</code></pre>
                </div>
                <figcaption class="figure-caption"><em>Untempering in Python code</em></figcaption>
            </figure>
            <p></p>
            <button type="button" class="btn btn-primary" data-toggle="collapse" data-target="#untempering-example">Click here for a more in depth explanation.</button>
            <div id="untempering-example" class="collapse">
                <p><a href="https://nayak.io/posts/mersenne_twister/">This page</a> explains the procedure well. To show how it works, I'll be continuing with the example from the previous example.</p>
                <h4>Step 4:</h4>
                <p>Step 4 can be reversed by simply redoing step 4 of the tempering process. This is because <code id="inline-code">(a XOR b) XOR b = a</code>. Moreover, after the bitshift, the first 18 bits of the Step 3 value of <code id="inline-code">y</code> are preserved. Thus, when the bitshift occurs again, the bits we need are still there.</p>
                <div>
                    <pre id="code-block"><code>11100000000101100101011101011101 XOR
00000000000000000001001010001110
=
11100000000101100110111101011000</code></pre>
                </div>

                <h4>Step 3:</h4>
                <p>Similarly, step 3 can be reversed by doing step 3 in the tempering process again.</p>
                <div>
                    <pre id="code-block"><code>00110111101011000000000000000000 AND
11101111110001100000000000000000
=
00100111100001000000000000000000 XOR
01001010001110100010101101011000
=
11000111100100100110111101011000</code></pre>
                </div>

                <h4>Step 2:</h4>
                <p>This step is a little bit more complicated but it essentially relies on repeating step 2 of the tempering process with the application of bitmasks. The reason for this is that is because each tome only gets us 7 bits at a time. The github repo I used for the code did this all in one step, while the page I linkes above which has the explanation did it using a loop. After applying that step, this is the result: <code id="inline-code">11011110101101100110101101011000</code>.</p>

                <h4>Step 1:</h4>
                <p>In step 1 of the tempering process, there is a bitshift to the right by 11. Since 11 is less than half of 32, if we just repeat this, weâ€™re going to run into an issue.</p>
                <div>
                    <pre id="code-block"><code>11011110101101100110101101011000 XOR
00000000000110111101011011001101
=
11011110101011011011110110010101</code></pre>
                </div>
                    
                <p>If we compare this to our untempered value (<code id="inline-code">11011110101011011011111011101111</code>), we see that only the first 22 bits are correct. To solve this we can simply xor once more but this time with our original value bitshifted by 22 bits. </p>
                    
                <div><pre id="code-block"><code>11011110101011011011110110010101 XOR
00000000000000000000001101111010
=
11011110101011011011111011101111</code></pre>
                </div>
                <p>This is our untempered value, so we have undone the process!</p>
            </div>

            <p></p>
            <p>Thus, we can untemper all the values and derive the seed &hellip; or can we? Turns out, when <code id="inline-code">random.setstate()</code> is called, it does two things. It sets the internal state array, but it also sets the index (i.e which position in that array the randomised values should start from). In the code above, this is done by adding <code id="inline-code">(625, )</code> to the array. However, this is greater than 624, which signals to the module that it is time to generate a new state by twisting. Thus, simply untempering the values isn&rsquo;t enough.</p>

            <p></p>
            <h4>Twisting</h4>
            <p>The twist is also done using bitwise operations, but it is slightly more complex than tempering as it requires more numbers from the state.</p>
            <!-- Twisting function -->
            <figure class="figure">
                <div>
                    <pre id="code-block"><code>def twist():
    for i in range(624):
        x = state[i] &amp; 0x80000000 | (state[(i+1) % 624] &amp; 0x7FFFFFFF)
        xA = x &gt;&gt; 1
        if x % 2 != 0:
            xA ^= 0x9908B0DF
        state[i] = state[(i + 397) % 624] ^ xA
    index = 0</code></pre>
                </div>
                <figcaption class="figure-caption"><em>Twisting in Python code</em></figcaption>
            </figure>
            <p>For each element, <code id="inline-code">i</code>, in the state, the following operations are carried out:</p>
            <ol>
            <li>The first bit of <code id="inline-code">state[i]</code> and the last 31 bits of <code id="inline-code">state[i+1]</code> are combined to make a new number, <code id="inline-code">x</code>.</li>
            <li>This number is then bitshifted once to the right to get <code id="inline-code">xA</code>. </li>
            <li>If <code id="inline-code">x</code> is odd, <code id="inline-code">xA</code> is xored with <code id="inline-code">10011001000010001011000011011111</code>. (note that the first bit of this is 1)</li>
            <li><code id="inline-code">state[i]</code> is assigned <code id="inline-code">xA</code> xored with <code id="inline-code">state[(i+397)%624]</code>.</li>
            </ol>
            <p>At the end, the index is reset which is incremented internally as more numbers are required.</p>

            <p></p>
            <h4>Untwisting</h4>
            <p>For untwisting, I found <a href="https://jazzy.id.au/2010/09/25/cracking_random_number_generators_part_4.html">this page</a>. The process can be broken into the following steps:</p>
            <ol>
            <li>Recover <code id="inline-code">xA</code> by xoring <code id="inline-code">state[i]</code> with <code id="inline-code">state[(i+397)%624]</code>.</li>
            <li>Figure out whether <code id="inline-code">x</code> was odd or even by checking the value of its first bit. This will be 1 if <code id="inline-code">x</code> was odd. This is because of the xor operation in step 3 of twisting. If <code id="inline-code">x</code> was odd, then xor <code id="inline-code">xA</code> with <code id="inline-code">10011001000010001011000011011111</code>.</li>
            <li>Get <code id="inline-code">x</code> from <code id="inline-code">xA</code> by bitshifting and fix the last bit based on whether <code id="inline-code">x</code> was odd or not.</li>
            </ol>
            
            <p>This would get us <code id="inline-code">x</code>, but remember that only the first bit of <code id="inline-code">x</code> is from <code id="inline-code">state[i]</code>. The rest are from <code id="inline-code">state[i+1]</code>. This however is an easy problem to fix and can be fixed by repeating the aforementioned 3 steps for <code id="inline-code">state[i-1]</code> as well and taking the needed bits. Another thing to note is that the untwisting process has to be done starting at <code id="inline-code">state[623]</code> because it&rsquo;s in the reverse order of twisting.</p>
            <p>Putting this into code gives the following:</p>
            <figure class="figure">
                <div>
                    <pre id="code-block"><code>def untwist():
    for i in range(623, -1, -1):
        tmp = state[i]
        tmp ^= state[(i + 397) % 624]
        if (tmp &amp; 0x80000000) == 0x80000000:
            tmp ^= 0x9908B0DF
        result = (tmp &lt;&lt; 1) &amp; 0x80000000

        tmp = state[(i - 1 + 624) % 624] 
        tmp ^= state[(i - 1 + 397) % 624]
        if (tmp &amp; 0x80000000) == 0x80000000:
            tmp ^= 0x9908B0DF
            result |= 1
        result |= (tmp &lt;&lt; 1) &amp; 0x7fffffff
        state[i] = result</code></pre>
                </div>
                <figcaption class="figure-caption">Untwisting in Python</figcaption>
            </figure>
        </div>
    </body>
</html>